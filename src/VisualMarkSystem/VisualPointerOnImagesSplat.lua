---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Bergi.
--- DateTime: 18.05.2020 21:36
---


---CreateVisualPointerForUnit
---@param hero "герой"
---@param flag "Параметры_завершения"
---@param long "Число_блоков"
---@param step "Ширина_блока"
---@param minlong "Милимальное_число_отображаемых_блоков"ы
function CreateVisualPointerForUnitBySplat(hero,flag,long,step,minlong)
	local image={}
	local image2={}
	local pid=GetPlayerId(GetOwningPlayer(hero))
	local data=HERO[pid]
	local size=step/3
	local r60=70//size
	local r40=50//size
	local LastMouseX=0

	for i=1,long do
		image[i]=CreateImage("AdmiralAssets\\pointerORIG",16,16,9999,4000,4000,0,0,0,0,4)

		--SetImageConstantHeight(image[i],true,250)

		SetImageColor(image[i],0,255,0,128)
		SetImageRenderAlways(image[i], true)
		if GetLocalPlayer()~=Player(pid) then
			ShowImage(image[i],false)
		else
			ShowImage(image[i],true)
		end

		image2[i]=CreateImage("AdmiralAssets\\pointerORIG",16,16,9999,4000,4000,0,0,0,0,4)

		--SetImageAboveWater(image2[i],false, false)
		--SetImageConstantHeight(image2[i],true,250)

		SetImageColor(image2[i],0,255,0,128)
		SetImageRenderAlways(image2[i], true)
		if GetLocalPlayer()~=Player(pid) then
			ShowImage(image2[i],false)
		else
			ShowImage(image2[i],true)
		end
	end



	local distance=0
	local mouseMoving=false
	local savedDistance=0
	local lastAngle=0
	local delta=0
	local angle=0



	local function Destroy()
		DestroyTimer(GetExpiredTimer())
		--data.MarkIsActivated=true
		--print("destroy")
		for i=1,#image do
			DestroyImage(image[i])
			DestroyImage(image2[i])
		end
	end
	local curAngle=180+AngleBetweenXY( GetPlayerMouseX[pid], GetPlayerMouseY[pid],GetUnitXY(hero))/bj_DEGTORAD--GetUnitFacing(hero)
	--print(curAngle)
	local iter=0
	local curBlock=0
	TimerStart(CreateTimer(), TIMER_PERIOD, true, function()
		--angle=GetUnitFacing(hero)
		--local xs,ys=MoveXY(GetUnitX(hero),GetUnitY(hero),10,angle-30)
		local rxs,rys=GetUnitXY(hero)
		if flag==2 then
			rxs,rys=data.xStand,data.yStand
		end
		local xs,ys=MoveXY(rxs-16,rys-16,40,curAngle)--стартовое смещение и это центр юнита



		local xs2,ys2=0,0
		iter=iter+1

			xs,ys=MoveXY(xs,ys,40,curAngle+90)
			xs2,ys2=MoveXY(xs,ys,80,curAngle-90)
		local errAngle=2.5
		if flag==2 then
			errAngle=5
		end

		angle=errAngle+AngleBetweenXY(xs, ys, GetPlayerMouseX[pid], GetPlayerMouseY[pid])/bj_DEGTORAD--data.AngleMouse
		local distMouse=DistanceBetweenXY(GetPlayerMouseX[pid], GetPlayerMouseY[pid],rxs,rys)
		--print(distMouse)
		if distMouse>=90 then
			curAngle=lerpTheta(curAngle,angle,TIMER_PERIOD*8)
		end

		if LastMouseX == GetPlayerMouseX[pid] then
			mouseMoving=false
			--savedDistance=DistanceBetweenXY(GetPlayerMouseX[pid],GetPlayerMouseY[pid],rxs,rys)
		else
			mouseMoving=true
			--print("движется")
		end
		LastMouseX = GetPlayerMouseX[pid]
		delta=curAngle-lastAngle
		lastAngle=curAngle


		--angle=data.LastTurn--/bj_DEGTORAD


		--print(delta)
		if mouseMoving then
			distance=DistanceBetweenXY(GetPlayerMouseX[pid],GetPlayerMouseY[pid],rxs,rys)
			savedDistance=DistanceBetweenXY(GetPlayerMouseX[pid],GetPlayerMouseY[pid],rxs,rys)
		else
			distance=savedDistance
		end
		local block=0

		--print(distance)
		for _=1,#image do
			distance=distance-step
			if distance>=0 then
				block=block+1
			end
		end

		if block<=61 then
			block=61
		end
		--print(block)
		curBlock=R2I(lerpTheta(curBlock,block,TIMER_PERIOD*16))

		if minlong~=nil then
			if minlong>=curBlock then
				curBlock=minlong
			end
		end
		--print(block)
		local k=0
		local k2=0
		for i=1,#image do
			if i<curBlock then
				local nx,ny=0,0

				--print("block="..block)



				if i>=curBlock-r60 and i<=curBlock-r40 then
					--print(i.."поворот на 90")
					k=k+1
					local axs,ays=MoveXY(xs,ys,(curBlock-r60)*step,curAngle)
					nx,ny=MoveXY(axs,ays,step*k,curAngle+90)
					SetImagePosition(image[i],nx,ny,0)

					local axs2,ays2=MoveXY(xs2,ys2,(curBlock-r60)*step,curAngle)
					nx,ny=MoveXY(axs2,ays2,step*k,curAngle-90)
					SetImagePosition(image2[i],nx,ny,0)

				else
					if i>=curBlock-r40 then
						--print("Косая 45")

						local axs,ays=MoveXY(xs,ys,(curBlock-r60)*step,curAngle)
						local axs2,ays2=MoveXY(xs2,ys2,(curBlock-r60)*step,curAngle)
						local px,py,px2,py2=0,0,0,0

							px,py=MoveXY(axs,ays,step*k,curAngle+90)
							px2,py2=MoveXY(axs2,ays2,step*k,curAngle-90)

						k2=k2+1
						if curBlock<=r60 then
							--print("лишняяотрисовка")
							--k2=block
							SetImagePosition(image[i],6000,6000,0)
							SetImagePosition(image2[i],6000,6000,0)
						else

							nx,ny=MoveXY(px,py,step*(k2),curAngle-45)
							SetImagePosition(image[i],nx,ny,0)
							nx,ny=MoveXY(px2,py2,step*(k2),curAngle+45)
							SetImagePosition(image2[i],nx,ny,0)

						end

					else
						nx,ny=MoveXY(xs,ys,step*i,curAngle)--вот так всё отлично работает
						SetImagePosition(image[i],nx,ny,0)
						nx,ny=MoveXY(xs2,ys2,step*i,curAngle)
						SetImagePosition(image2[i],nx,ny,0)
					end
				end



				--local z=GetTerrainZ(nx,ny)
				--SetImageConstantHeight()
				--ShowImage(image[i],true)
			else --меньшение
				SetImagePosition(image[i],6000,6000,0)
				SetImagePosition(image2[i],7000,7000,0)
				--ShowImage(image[i],false)
			end
		end

		if flag==1 then
			if not data.MarkIsActivated then
				Destroy()
			end
		elseif flag==2 then
			if data.StartCanon then
				Destroy()
			end
		end
	end)
end